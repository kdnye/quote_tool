import streamlit as st
import pandas as pd
import numpy as np
import os
from io import BytesIO
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
import requests

# === Load Excel Workbook ===
rates_file_path = "HotShot Quote.xlsx"
workbook = pd.read_excel(rates_file_path, sheet_name=None)

rates_df = workbook["Hotshot Rates"]
accessorials_df = workbook["Accessorials"]

# Clean + standardize column names
rates_df.columns = rates_df.columns.str.strip().str.upper()

# Ensure numeric
rates_df["MILES"] = pd.to_numeric(rates_df["MILES"], errors="coerce")

# === Google Maps API Distance Lookup ===
def get_distance_miles(origin_zip, destination_zip):
    api_key = os.getenv("GOOGLE_MAPS_API_KEY")
    if not api_key:
        return None
    url = f"https://maps.googleapis.com/maps/api/directions/json?origin={origin_zip}&destination={destination_zip}&mode=driving&key={api_key}&sensor=false"
    try:
        response = requests.get(url)
        data = response.json()
        if data["status"] == "OK":
            meters = data["routes"][0]["legs"][0]["distance"]["value"]
            return meters / 1609.344
    except Exception:
        return None

# === UI ===
st.title("üöõ Hotshot Quote Calculator")

col1, col2 = st.columns(2)
with col1:
    origin = st.text_input("Origin Zip Code")
    destination = st.text_input("Destination Zip Code")
    weight = st.number_input("Weight (lbs)", step=1)

with col2:
    accessorial_total = 0
    selected = []
    st.subheader("üì¶ Accessorials")
    options = {
        "4hr Window Pickup/Delivery": "4hr Window",
        "Specific Time Pickup/Delivery": "Special",
        "Afterhours Pickup (Return Only)": "After Hours",
        "Weekend Pickup/Delivery": "Weekend",
        "Two-Man Team Pickup/Delivery": "Two Man",
        "Liftgate Pickup/Delivery": "Liftgate",
    }
    for label, key in options.items():
        enabled = st.checkbox(label)
        if enabled:
            cost = float(accessorials_df.loc[0, key])
            accessorial_total += cost
            selected.append((label, cost))

# === Trigger Quote ===
if st.button("Get Quote"):
    miles = get_distance_miles(origin, destination)
    if miles is None:
        st.warning("Could not fetch distance from Google Maps.")
        miles = 0

    # Lookup zone based on miles
    zone_lookup = rates_df[["MILES", "ZONE"]].dropna()
    zone_lookup["MILES"] = pd.to_numeric(zone_lookup["MILES"], errors="coerce")
    zone_lookup = zone_lookup.dropna().sort_values("MILES")

    zone = None
    for _, row in zone_lookup.iterrows():
        if miles <= row["MILES"]:
            zone = row["ZONE"]
            break

    # Fallback to Zone X if no match found
    if not zone:
        zone = "X"

    st.write(f"Matched Zone: **{zone}**")

    is_zone_x = zone.upper() == "X"
    per_lb = float(rates_df.loc[rates_df["ZONE"] == zone, "PER LB"].values[0])
    fuel_pct = float(rates_df.loc[rates_df["ZONE"] == zone, "FUEL"].values[0]) / 100
    min_col = "MIN"
    weight_break = float(rates_df.loc[rates_df["ZONE"] == zone, "WEIGHT BREAK"].values[0])

    # Backward-compatible per-mile for Zone X stored in MIN
    if is_zone_x:
        per_mile = float(rates_df.loc[rates_df["ZONE"] == zone, min_col].values[0])
        subtotal = (miles * per_mile) + (weight * per_lb) + accessorial_total
        quote_sub = subtotal * (1 + fuel_pct)
    else:
        min_charge = float(rates_df.loc[rates_df["ZONE"] == zone, min_col].values[0])
        if weight > weight_break:
            base = ((weight - weight_break) * per_lb) + min_charge
        else:
            base = min_charge
        quote_sub = (base + accessorial_total) * (1 + fuel_pct)

    quote_total = quote_sub * 1.25

    # === Output ===
    st.divider()
    st.subheader("üßæ Final Quote")
    st.write(f"**Zone**: {zone}")
    st.write(f"**Distance**: {miles:.2f} miles")
    st.write(f"**Total Quote**: üí∞ ${quote_total:,.2f}")

    # === Export to Excel ===
    quote_data = {
        "Origin": origin,
        "Destination": destination,
        "Miles": miles,
        "Zone": zone,
        "Weight": weight,
        "Fuel %": fuel_pct,
        "Accessorial Total": accessorial_total,
        "Total Quote": quote_total,
        "Date": datetime.now().strftime("%Y-%m-%d %H:%M")
    }
    quote_df = pd.DataFrame([quote_data])

    output = BytesIO()
    with pd.ExcelWriter(output, engine="xlsxwriter") as writer:
        quote_df.to_excel(writer, index=False)
        if selected:
            pd.DataFrame(selected, columns=["Accessorial", "Charge"]).to_excel(writer, sheet_name="Accessorials", index=False)

    st.download_button("‚¨áÔ∏è Download Quote Excel", data=output.getvalue(), file_name="quote.xlsx")

    # === Optional Email Section ===
    st.divider()
    st.subheader("üìß Send Quote via Email")
    recipient = st.text_input("Recipient Email")
    if st.button("Send Email"):
        try:
            sender_email = os.getenv("QUOTE_SENDER_EMAIL")
            sender_pass = os.getenv("QUOTE_SENDER_PASS")
            if not (sender_email and sender_pass):
                st.error("Missing QUOTE_SENDER_EMAIL or QUOTE_SENDER_PASS env vars.")
            else:
                msg = MIMEMultipart()
                msg["From"] = sender_email
                msg["To"] = recipient
                msg["Subject"] = "Hotshot Quote"
                msg.attach(MIMEText(f"Quote from {origin} to {destination}. Total: ${quote_total:,.2f}", "plain"))

                part = MIMEApplication(output.getvalue(), Name="quote.xlsx")
                part["Content-Disposition"] = 'attachment; filename="quote.xlsx"'
                msg.attach(part)

                with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
                    server.login(sender_email, sender_pass)
                    server.send_message(msg)

                st.success("Email sent successfully.")
        except Exception as e:
            st.error(f"Error sending email: {e}")
